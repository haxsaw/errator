<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="generator" content="ReText 7.0.1">
<title>Using errator</title>
</head>
<body>
<div class="document" id="using-errator">
<h1 class="title">Using errator</h1>
<ol class="arabic simple">
<li><a class="reference external" href="#if-you-don-t-read-anything-else-read-this">If you don't read anything else, READ THIS</a></li>
<li><a class="reference external" href="#errator-s-operation">errator's operation</a></li>
<li><a class="reference external" href="#capturing-the-narration">Capturing the narration</a></li>
<li><a class="reference external" href="#skipping-decorating-functions">Skipping decorating functions</a></li>
<li><a class="reference external" href="#customizing-the-narration">Customizing the narration</a></li>
<li><a class="reference external" href="#getting-more-details-with-contexts">Getting more details with contexts</a></li>
<li><a class="reference external" href="#advanced-fragment-access">Advanced fragment access</a></li>
<li><a class="reference external" href="#verbose-narrations">Verbose narrations</a></li>
<li><a class="reference external" href="#testing-and-debugging">Testing and debugging</a></li>
<li><a class="reference external" href="#tidying-up-stack-traces">Tidying up stack traces</a></li>
<li><a class="reference external" href="#overhead">Overhead</a></li>
<li><a class="reference external" href="#usage-tips">Usage tips</a></li>
</ol>
<p><tt class="docutils literal">errator</tt> is a fairly small library that's easy to wrap your head around. While basic
usage is fairly simple, <tt class="docutils literal">errator</tt> also allows you more sophisticated uses in multi-threaded
programs where each thread can have its own exception narration, as well as being able to
manage partial narrations.</p>
<p>There are a couple of anti-patterns in <tt class="docutils literal">errator's</tt> use which are important to understand, so
we'll lead off with addressing those before launching into a more general discussion of using
<tt class="docutils literal">errator</tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The documentation generally discusses decorating functions with <tt class="docutils literal">errator</tt>, but <tt class="docutils literal">errator's</tt> decorators can also be used to decorate methods. For brevity, when 'function' is used it should be assumed to mean 'function or method'.</p>
</div>
<div class="section" id="if-you-don-t-read-anything-else-read-this">
<h1>If you don't read anything else, READ THIS</h1>
<p><tt class="docutils literal">errator</tt> decorators, context managers, and narration management functions work together to
manage a set of per-thread stacks of &quot;narration fragments&quot;. In &quot;normally&quot; operating code (that is, with no exceptions), these fragments are created at the start of a function or context, and discarded
when the function or context completes without an exception (push on call, pop on return).</p>
<p>But when an exception occurs, the fragment is retained, and as the exception passes un-caught up the stack through other <tt class="docutils literal">errator</tt> managed functions or contexts additional fragments may also be retained, until the exception is caught and <tt class="docutils literal">errator</tt> is told that it may finally discard the fragments. This discarding may be done automatically or under programmatic control, depending on how <tt class="docutils literal">errator</tt> is to be used, but the key is that unless <tt class="docutils literal">errator</tt> discards the fragments, they will simply keep growing in number and may cause memory issues if code experiences numerous errors without disposing of the fragments, not to mention yielding confusing narrations of exceptions.</p>
<p>There are two anti-patterns that can lead to this situation to be aware of.</p>
<div class="section" id="anti-pattern-1-catching-the-exception-outside-of-errator-s-view">
<h2>Anti-pattern #1-- catching the exception outside of <tt class="docutils literal">errator's</tt> view</h2>
<p>If you catch an exception in a function that hasn't been decorated with <tt class="docutils literal">errator</tt> decorators (and there are no more <tt class="docutils literal">errator</tt>-decorated functions or contexts at a more global level in the call stack), it will leak narration fragments and the narration will grow, making it useless:</p>
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">nf1</span><span class="p">():</span>
    <span class="s2">&quot;NOTE: not decorated with 'narrate()'&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nf2</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">story</span> <span class="o">=</span> <span class="n">get_narration</span><span class="p">()</span>
        <span class="c1"># handle the exception</span>

<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;I starting to 'nf2'&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf2</span><span class="p">():</span>
    <span class="n">nf3</span><span class="p">()</span>

<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;I've been asked to 'nf3'&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf3</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;catch me!&quot;</span><span class="p">)</span>

<span class="c1"># some time later...</span>
<span class="n">nf1</span><span class="p">()</span>
</pre>
<p>The problem is that nf1() isn't decorated with <tt class="docutils literal">narrate()</tt>, and hence <tt class="docutils literal">errator</tt> doesn't know that
the exception was handled. Try it-- enter the above code and call nf1() twice, and then look at the
returned narration from <tt class="docutils literal">get_narration()</tt>. <strong>Remember</strong>: this isn't a problem if there is an <tt class="docutils literal">errator</tt> decorated function or context at a more global level in the call stack.</p>
<p>You can fix this a couple of ways:</p>
<p><strong>Approach #1:</strong></p>
<pre class="code python literal-block">
<span class="c1"># this approach will cause ``errator`` to automatically clean fragments:</span>

<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;I'm starting nf1&quot;</span><span class="p">)</span>  <span class="c1"># we added decoration to the ``nf1()`` function</span>
<span class="k">def</span> <span class="nf">nf1</span><span class="p">():</span>
    <span class="s2">&quot;NOTE: NOW decorated with 'narrate()'&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nf2</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">story</span> <span class="o">=</span> <span class="n">get_narration</span><span class="p">()</span>
        <span class="c1"># handle the exception</span>

<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;I starting to 'nf2'&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf2</span><span class="p">():</span>
    <span class="n">nf3</span><span class="p">()</span>

<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;I've been asked to 'nf3'&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf3</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;catch me!&quot;</span><span class="p">)</span>

<span class="c1"># some time later...</span>
<span class="n">nf1</span><span class="p">()</span>
</pre>
<p><strong>Approach #2</strong></p>
<pre class="code python literal-block">
<span class="c1"># in this approach, you manually clear out the narration fragments</span>

<span class="k">def</span> <span class="nf">nf1</span><span class="p">():</span>
    <span class="s2">&quot;NOTE: no decoration, but we clean up in the exception clause&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nf2</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">story</span> <span class="o">=</span> <span class="n">get_narration</span><span class="p">()</span>
        <span class="n">reset_narration</span><span class="p">()</span>  <span class="c1"># CLEANS UP FRAGMENTS</span>
        <span class="c1"># handle the exception</span>

<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;I starting to 'nf2'&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf2</span><span class="p">():</span>
    <span class="n">nf3</span><span class="p">()</span>

<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;I've been asked to 'nf3'&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf3</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;catch me!&quot;</span><span class="p">)</span>

<span class="c1"># some time later...</span>
<span class="n">nf1</span><span class="p">()</span>
</pre>
</div>
<div class="section" id="anti-pattern-2-shutting-off-automatic-cleanup-but-not-clearing-up-fragments">
<h2>Anti-pattern #2: Shutting off automatic cleanup but not clearing up fragments</h2>
<p>For more complex uses of <tt class="docutils literal">errator</tt>, you can turn off automatic fragment cleanup, but if
you do so then you <strong>must</strong> handle cleanup yourself. The following will suffer from the same
leakage/growing narration as the first anti-pattern:</p>
<pre class="code python literal-block">
<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;Look out-- I'm about to nf1()!&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf1</span><span class="p">():</span>
    <span class="s2">&quot;we've got nf1 decorated&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nf2</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">story</span> <span class="o">=</span> <span class="n">get_narration</span><span class="p">()</span>
        <span class="c1"># handle the exception</span>

<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;I starting to 'nf2'&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf2</span><span class="p">():</span>
    <span class="n">nf3</span><span class="p">()</span>

<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;I've been asked to 'nf3'&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf3</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;catch me!&quot;</span><span class="p">)</span>

<span class="n">set_narration_options</span><span class="p">(</span><span class="n">auto_prune</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c1"># later, in the same thread:</span>
<span class="n">nf1</span><span class="p">()</span>
</pre>
<p>In this example, even though all functions in the call chain are decorated with <tt class="docutils literal">narrate()</tt>,
we'll still leak fragements and allow the narration to grow. This is because
<tt class="docutils literal">set_narration_options()</tt> was used to turn off &quot;auto_prune&quot;, which makes <tt class="docutils literal">errator</tt> not discard
fragments when exceptions have been handled. Note that this has to happen in the same thread;
each thread can have different narration options.</p>
<p>If you want to have auto_prune off (and there are cases where you might want to do this), fixing
this is like the second solution to the first anti-pattern:</p>
<pre class="code python literal-block">
<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;Look out-- I'm about to nf1()!&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf1</span><span class="p">():</span>
    <span class="s2">&quot;we've got nf1 decorated&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nf2</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">story</span> <span class="o">=</span> <span class="n">get_narration</span><span class="p">()</span>
        <span class="n">reset_narration</span><span class="p">()</span>         <span class="c1">#CLEANS UP THE FRAGMENTS</span>
        <span class="c1"># handle the exception</span>

<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;I starting to 'nf2'&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf2</span><span class="p">():</span>
    <span class="n">nf3</span><span class="p">()</span>

<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;I've been asked to 'nf3'&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf3</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;catch me!&quot;</span><span class="p">)</span>

<span class="n">set_narration_options</span><span class="p">(</span><span class="n">auto_prune</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c1"># later, in the same thread:</span>
<span class="n">nf1</span><span class="p">()</span>
</pre>
<p>Here, we've simply called <tt class="docutils literal">reset_narration()</tt> after the narration text has been acquired, and
this gets rid of all fragments for the thread.</p>
</div>
</div>
<div class="section" id="errator-s-operation">
<h1><tt class="docutils literal">errator's</tt> Operation</h1>
<p>Let's look at an example of a set of functions that can be decorated with <tt class="docutils literal">errator's</tt> <tt class="docutils literal">narrate()</tt> decorator. Let's suppose we have a set of functions <tt class="docutils literal">nf1</tt> through <tt class="docutils literal">nf6</tt>, where <tt class="docutils literal">nf1</tt> calls <tt class="docutils literal">nf2</tt>, <tt class="docutils literal">nf2</tt> calls <tt class="docutils literal">nf3</tt>, and so forth. If we stopped in the debugger in <tt class="docutils literal">nf6</tt>, Python would report the stack like so:</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">func</th>
<th class="head">execution point</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>nf1</td>
<td>&nbsp;</td>
</tr>
<tr><td>nf2</td>
<td>&nbsp;</td>
</tr>
<tr><td>nf3</td>
<td>&nbsp;</td>
</tr>
<tr><td>nf4</td>
<td>&nbsp;</td>
</tr>
<tr><td>nf5</td>
<td>&nbsp;</td>
</tr>
<tr><td>nf6</td>
<td>&lt;-- current frame</td>
</tr>
</tbody>
</table>
<p>When we decorate functions with <tt class="docutils literal">narrate()</tt>, additional stack frames are added to the trace; we won't show those here, but instead will show what fragments are managed as the execution progresses. Here's the retained narration fragments if <tt class="docutils literal"><span class="pre">nf1..nf6</span></tt> are all decorated with <tt class="docutils literal">narrate()</tt> and the current function is <tt class="docutils literal">nf4</tt>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="39%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">func</th>
<th class="head">execution point</th>
<th class="head">fragments for funcs</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>nf1</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>nf2</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>nf3</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>nf4</td>
<td>&lt;-- current frame</td>
<td>nf1, nf2, nf3, nf4</td>
</tr>
<tr><td>nf5</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>nf6</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>When <tt class="docutils literal">nf4</tt> returns, the fragments are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="39%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">func</th>
<th class="head">execution point</th>
<th class="head">fragments for funcs</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>nf1</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>nf2</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>nf3</td>
<td>&lt;-- current frame</td>
<td>nf1, nf2, nf3</td>
</tr>
<tr><td>nf4</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>nf5</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>nf6</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>Note that the fragment for <tt class="docutils literal">nf4</tt> is removed.</p>
<p>Now suppose that we have an exception in <tt class="docutils literal">nf6</tt>, but the exception isn't captured until <tt class="docutils literal">nf3</tt>, at which point the exception is caught and doesn't propagate up the stack any further. This next table shows the fragments present as the functions either return and the exception propagates upward:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="36%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">func</th>
<th class="head">execution point</th>
<th class="head">fragments for funcs</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>nf1</td>
<td>normal return</td>
<td>nf1</td>
</tr>
<tr><td>nf2</td>
<td>normal return</td>
<td>nf1,nf2</td>
</tr>
<tr><td>nf3</td>
<td>exc handled</td>
<td>nf1,nf2,nf3,nf4,nf5,nf6</td>
</tr>
<tr><td>nf4</td>
<td>exc passes thru</td>
<td>nf1,nf2,nf3,nf4,nf5,nf6</td>
</tr>
<tr><td>nf5</td>
<td>exc passes thru</td>
<td>nf1,nf2,nf3,nf4,nf5,nf6</td>
</tr>
<tr><td>nf6</td>
<td>exception raised</td>
<td>nf1,nf2,nf3,nf4,nf5,nf6</td>
</tr>
</tbody>
</table>
<p>Notice that in <tt class="docutils literal">nf3</tt> where the exception is handled we still have all the fragments for all stack frames between the exception origin and the handler, but once the handler returns and <tt class="docutils literal">errator</tt> sees that the exception isn't propagating further it removes the fragments that are no longer useful in narrating an exception (this makes <tt class="docutils literal">nf3</tt> a good place to acquire the narration for the exception; more on that later).</p>
</div>
<div class="section" id="capturing-the-narration">
<h1>Capturing the narration</h1>
<p>Let's repeat the example from earlier, where we said that an exception was caught and processed in <tt class="docutils literal">nf3</tt>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="36%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">func</th>
<th class="head">execution point</th>
<th class="head">fragments for funcs</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>nf1</td>
<td>normal return</td>
<td>nf1</td>
</tr>
<tr><td>nf2</td>
<td>normal return</td>
<td>nf1,nf2</td>
</tr>
<tr><td>nf3</td>
<td>exc handled</td>
<td>nf1,nf2,nf3,nf4,nf5,nf6</td>
</tr>
<tr><td>nf4</td>
<td>exc passes thru</td>
<td>nf1,nf2,nf3,nf4,nf5,nf6</td>
</tr>
<tr><td>nf5</td>
<td>exc passes thru</td>
<td>nf1,nf2,nf3,nf4,nf5,nf6</td>
</tr>
<tr><td>nf6</td>
<td>exception raised</td>
<td>nf1,nf2,nf3,nf4,nf5,nf6</td>
</tr>
</tbody>
</table>
<p>If <tt class="docutils literal">nf3</tt> catches the exception, it's probably a good place to grab the exception narration
(this isn't required, but it may be a natural place). Suppose <tt class="docutils literal">nf3()</tt> looks like the following:</p>
<pre class="code python literal-block">
<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;While I was running nf3&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf3</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nf4</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">MyException</span><span class="p">:</span>
        <span class="n">story</span> <span class="o">=</span> <span class="n">get_narration</span><span class="p">()</span>
</pre>
<p>In the <tt class="docutils literal">except</tt> clause, we call <tt class="docutils literal">get_narration()</tt> to acquire a list of strings that are the narration for the exception. This will return the entire narration that exists for this call stack; that is, it will give a list of narration fragment strings for <tt class="docutils literal">nf1()</tt> through <tt class="docutils literal">nf6()</tt>.</p>
<p>But perhaps the whole narration isn't wanted; perhaps all that's desired is the narration for
<tt class="docutils literal">nf3()</tt> through <tt class="docutils literal">nf6()</tt>, as the the narrations before this point actually make the exception narration less clear. You can trim your narration down with by calling <tt class="docutils literal">get_narration()</tt> with the keyword argument <tt class="docutils literal">from_here</tt> set to True:</p>
<pre class="code python literal-block">
<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;While I was running nf3...&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf3</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nf4</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">MyException</span><span class="p">:</span>
        <span class="n">story</span> <span class="o">=</span> <span class="n">get_narration</span><span class="p">(</span><span class="n">from_here</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre>
<p>This will only return the narration strings from the current function to the function that's the source of the exception, in this case <tt class="docutils literal">nf3()</tt> through <tt class="docutils literal">nf6()</tt>. The <tt class="docutils literal">from_here</tt> argument allows you to control how much narration is returned from <tt class="docutils literal">get_narration()</tt>. It defaults to False, meaning to return the entire narration.</p>
</div>
<div class="section" id="skipping-decorating-functions">
<h1>Skipping decorating functions</h1>
<p>What happens if you skip decorating some functions in a calling sequence? Nothing much; <tt class="docutils literal">errator</tt> simply won't have anything in it's narration for that function. Below, we indicate a decorated function with an <tt class="docutils literal">(e)</tt> before the function name, and skip decoration of some functions. When we get to <tt class="docutils literal">nf5</tt>, the captured fragments are as shown:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="38%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">func</th>
<th class="head">execution point</th>
<th class="head">fragments for funcs</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>(e)nf1</td>
<td>&nbsp;</td>
<td>nf1</td>
</tr>
<tr><td>(e)nf2</td>
<td>&nbsp;</td>
<td>nf1,nf2</td>
</tr>
<tr><td>nf3</td>
<td>&nbsp;</td>
<td>nf1,nf2</td>
</tr>
<tr><td>(e)nf4</td>
<td>&nbsp;</td>
<td>nf1,nf2,nf4</td>
</tr>
<tr><td>nf5</td>
<td>&lt;-- current frame</td>
<td>nf1,nf2,nf4</td>
</tr>
<tr><td>nf6</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>You can see that there's no narration fragment for function <tt class="docutils literal">nf3</tt>.</p>
</div>
<div class="section" id="customizing-the-narration">
<h1>Customizing the narration</h1>
<p>Suppose you have a function of several variables:</p>
<pre class="code python literal-block">
<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;While I was calling f...&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="c1"># do stuff</span>
</pre>
<p>And a narration with a fixed string doesn't give you enough information as to how the function was called if there was an exception. The <tt class="docutils literal">narrate()</tt> function allows you to supply it with a callable object instead of a string; this callable will be passed all the arguments that were passed to the function <cite>and must return a string</cite>, which will then be used as the descriptive string for the narration fragment. This function is <strong>only</strong> invoked if the decorated function raises an exception, otherwise it goes uncalled.</p>
<p>Lambdas provide a nice way to specify a function that yields a string:</p>
<pre class="code python literal-block">
<span class="nd">&#64;narrate</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;While I was calling f with x={} and y={}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="c1"># do stuff</span>
</pre>
<p>But you can supply any callable that can cope with the argument list to the decorated function. This allows your narrations to provide more details regarding the calling context of a particular function, since actual argument values can become part of the narration.</p>
</div>
<div class="section" id="getting-more-details-with-contexts">
<h1>Getting more details with contexts</h1>
<p>It may be the case that narration at the function level isn't granular enough. You may have a lengthy function or one that calls out to other libraries, each of which can raise exceptions of their own. It might be helpful to have narration capabilities at a more granular level to address this.</p>
<p>To support more granular narration, <tt class="docutils literal">errator</tt> provides a context manager that is created with
a call to <tt class="docutils literal">narrate_cm()</tt>. This context manager acts similarly to the <tt class="docutils literal">narrate()</tt>
decorator. First, a narration fragment is captured when the context is entered. If the context
exits &quot;normally&quot; the fragment is discarded. However, if an exception is raised during the
context, the fragment is retained as the exception propagates upward.</p>
<p>Suppose we have a function that does two web service calls during its execution, and we'd like to know narration details around each of these activities if any fails in our function. We can use <tt class="docutils literal">narrate_cm()</tt> to achieve this:</p>
<pre class="code python literal-block">
<span class="nd">&#64;narrate</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="s2">&quot;So call_em was invoked with x={} and y={}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">call_em</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="c1"># do some stuff to form the first WS call</span>
    <span class="k">with</span> <span class="n">narrate_cm</span><span class="p">(</span><span class="s2">&quot;...and I started the first web service call...&quot;</span><span class="p">):</span>
        <span class="c1"># do the web service call</span>

    <span class="c1"># extract data and do the second call, computing a string named ws2_req</span>
    <span class="k">with</span> <span class="n">narrate_cm</span><span class="p">(</span><span class="k">lambda</span> <span class="n">req</span><span class="p">:</span> <span class="s2">&quot;...I started WS call #2 call with {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">req</span><span class="p">),</span>
                    <span class="n">ws2_req</span><span class="p">):</span>
        <span class="c1"># do the second web service call</span>

    <span class="c1"># and whatever else...</span>
</pre>
<p>This example was constructed to illustrate a couple of uses. Similarly to <tt class="docutils literal">narrate()</tt>, <tt class="docutils literal">narrate_cm()</tt> can be called either with a fixed string, or a callable that returns a string which will be invoked only if there's an exception raised in the context.</p>
<p>The first use of <tt class="docutils literal">narrate_cm()</tt> simply passes a fixed string. If there's an exception during the first web service call, the string is retained, but when reported the string will be indented a few spaces to show that the narration fragment is within the scope of the function's narration.</p>
<p>The second use of <tt class="docutils literal">narrate_cm()</tt> passes a lambda as its callable. But unlike passing a callable to <tt class="docutils literal">narrate()</tt>, you must also supply the arguments to give the callable to <tt class="docutils literal">narrate_cm()</tt>, in this case the local variable <em>ws2_req</em>. This is because the context manager doesn't know what is important relative to the context-- the function arguments or the local variables. You may pass both postional and keyword arguments to <tt class="docutils literal">narrate_cm()</tt>.</p>
</div>
<div class="section" id="advanced-fragment-access">
<h1>Advanced fragment access</h1>
<p><tt class="docutils literal">errator</tt> provides a way to get copies of the actual objects where narration fragments are stored. There are a number of situations where this is useful:</p>
<ul class="simple">
<li>if more control over fragment formatting is required</li>
<li>if retention of the details of an error narration is required</li>
<li>you're just that way</li>
</ul>
<p>You can get these objects by using the <tt class="docutils literal">copy_narration()</tt> function. Instead of returning a list of strings like <tt class="docutils literal">get_narration()</tt> does, this function returns a list of <tt class="docutils literal">NarrationFragment</tt>
objects which are copies of the objects managed by <tt class="docutils literal">errator</tt> itself. The <tt class="docutils literal">copy_narration()</tt> function takes the same <tt class="docutils literal">thread</tt> and <tt class="docutils literal">from_here</tt> arguments as does <tt class="docutils literal">get_narration()</tt>, so you can control what objects are returned in the same manner. Useful methods on NarrationFragment objects are:</p>
<ul class="simple">
<li><tt class="docutils literal">tell()</tt>, which returns a string that is the fragment's part of the overall narration</li>
<li><tt class="docutils literal">fragment_exception_text()</tt>, which returns a string that describes the actual exception; really   only useful on the last fragment in the call chain</li>
</ul>
<p>Being a lower-level object, you should expect the rest of NarrationFragment's interface to be a bit more volatile, and should stick with calling <tt class="docutils literal">tell()</tt> if you wish to be isolated from change.</p>
</div>
<div class="section" id="verbose-narrations">
<h1>Verbose narrations</h1>
<p><strong>NOTE</strong>: Turning on verbose functionality has a material impact on <tt class="docutils literal">errator's</tt> performance, as the <tt class="docutils literal">inspect</tt> Python module is consulted to acquire file name and line number information. However, these costs are only incurred when there is an exception.</p>
<p>The story <tt class="docutils literal">errator</tt> tells is meant to be user-focused; that is, from the perspective of a program's semantics rather than from that of a stack trace. However, there may be circumstances where it would be helpful to have some of the information in a stack trace merged into the rendered narration. <tt class="docutils literal">errator</tt> supports this with the <tt class="docutils literal">verbose</tt> keyword on the <tt class="docutils literal">set_narration_options()</tt> function. It defaults to <tt class="docutils literal">False</tt>, but if set to <tt class="docutils literal">True</tt>, then each retrieved narration line will be followed by a line that reports the line number, function, and source file associated with the narration fragment.</p>
<p>Consider this narrated program in a file named verbose.py:</p>
<pre class="code python literal-block">
<span class="kn">from</span> <span class="sb">``</span><span class="n">errator</span><span class="sb">``</span> <span class="kn">import</span> <span class="nn">narrate_cm</span><span class="o">,</span> <span class="nn">narrate</span><span class="o">,</span> <span class="nn">get_narration</span><span class="o">,</span> <span class="nn">set_narration_options</span>

<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;So I started to 'nf1'...&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf1</span><span class="p">():</span>
    <span class="n">nf2</span><span class="p">()</span>

<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;...which occasioned me to 'nf2'&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf2</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">narrate_cm</span><span class="p">(</span><span class="s2">&quot;during which I started a narration context...&quot;</span><span class="p">):</span>
        <span class="n">nf3</span><span class="p">()</span>

<span class="nd">&#64;narrate</span><span class="p">(</span><span class="s2">&quot;...and that led me to finally 'nf3'&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nf3</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;oops&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">set_narration_options</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nf1</span><span class="p">()</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">get_narration</span><span class="p">():</span>
            <span class="k">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</pre>
<p>Which yields the following output when run:</p>
<pre class="code literal-block">
So I started to 'nf1'...
...which occasioned me to 'nf2'
  during which I started a narration context...
...and that led me to finally 'nf3', but exception type: Exception, value: 'oops' was raised
</pre>
<p>If we set <tt class="docutils literal">verbose=True</tt> in the <tt class="docutils literal">set_narration_options()</tt> call, then the output looks like the following:</p>
<pre class="code literal-block">
So I started to 'nf1'...
    line 5 in nf1, /home/tom/errator/docs/verbose.py
...which occasioned me to 'nf2'
    line 10 in nf2, /home/tom/errator/docs/verbose.py
  during which I started a narration context...
       line 10 in nf2, /home/tom/errator/docs/verbose.py
...and that led me to finally 'nf3', but exception type: Exception, value: 'oops' was raised
    line 14 in nf3, /home/tom/errator/docs/verbose.py
</pre>
<p>...thus letting you see the actual lines being executed when the exception is raised.</p>
</div>
<div class="section" id="testing-and-debugging">
<h1>Testing and debugging</h1>
<p>As <tt class="docutils literal">errator</tt> is meant to help you make sense when something goes wrong, it would be a shame if something
went wrong while <tt class="docutils literal">errator</tt> was doing its thing. But since <tt class="docutils literal">errator</tt> users can supply a callable to <tt class="docutils literal">narrate()</tt> and <tt class="docutils literal">narrate_cm()</tt>, there's the possibility that an error lurks in the callable itself, and <tt class="docutils literal">errator</tt> could raise an exception in trying to tell you about an exception. Worse, if there is a bug in a callable, you'd only know about it if an exception is raised, which may be difficult to force in testing, or may escape testing and only show up in production.</p>
<p>To help you find problems earlier, <tt class="docutils literal">errator</tt> provides an option that changes the rules regarding when fragments, and hence callables, are formatted. By adding:</p>
<pre class="code python literal-block">
<span class="n">set_default_options</span><span class="p">(</span><span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre>
<p>Before entering an <tt class="docutils literal">errator</tt> decorated function or managed context, you inform <tt class="docutils literal">errator</tt> that you wish to check the generation of every narration fragment, whether there's been an exception raised or not. You can also set the 'check' option on an existing narration's thread with:</p>
<pre class="code python literal-block">
<span class="n">set_narration_options</span><span class="p">(</span><span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre>
<p>which will set fragment checking only for the current thread's narration (or the thread named with the <tt class="docutils literal">thread=</tt> argument; see the documentation for <tt class="docutils literal">set_narration_options()</tt> for details).</p>
<p>When the <tt class="docutils literal">check</tt> option is True, every time a decorated function returns or a managed context exits, <tt class="docutils literal">errator</tt> formats the narration fragment, including calling any callable supplied to exercise the code it refers to. By setting check to True in your testing code, you can be sure that every narration fragment is generated, and hence every callable for a fragment is invoked. This helps you ensure that you have the correct number of arguments to your callable and raises confidence that the callable will operate correctly in a real exception situation (this isn't a guarantee, however, as the conditions that raise an exception my be different from those in testing).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You don't want to run production code with <tt class="docutils literal">check</tt> set to True (it defaults to False). This is because doing so incurs the execution time of every callable where the check==True applies, which can have significant performance impact on your code. <tt class="docutils literal">errator</tt> normally only invokes the callable if there's an exception, thus sparing your code from the call overhead and extra execution time. So be sure not have the check option set True in production.</p>
</div>
</div>
<div class="section" id="tidying-up-stack-traces">
<h1>Tidying up stack traces</h1>
<p><tt class="docutils literal">errator's</tt> <tt class="docutils literal">narrate()</tt> decorator wraps the function being decorated, which means that if you use the various stack and traceback reporting functions in the standard <tt class="docutils literal">traceback</tt> module, you can get materially longer traces than you'd otherwise like. If you'd rather not see these, <tt class="docutils literal">errator</tt> supplies a set of wrapper functions that are analogs of the functions in <tt class="docutils literal">traceback</tt> that strip out the <tt class="docutils literal">errator</tt> calls from returned objects or printed stack traces. These functions are all argument-compatible with the functions in <tt class="docutils literal">traceback</tt>. Specifically, <tt class="docutils literal">errator</tt> provides analogs to:</p>
<ul class="simple">
<li>extract_tb</li>
<li>extract_stack</li>
<li>format_tb</li>
<li>format_stack</li>
<li>format_exception_only</li>
<li>format_exception</li>
<li>print_tb</li>
<li>print_exception</li>
<li>print_exc</li>
<li>format_exc</li>
<li>print_last</li>
<li>print_stack</li>
</ul>
<p>...all of which remove traces of <tt class="docutils literal">errator</tt> from the output.</p>
</div>
<div class="section" id="overhead">
<h1>Overhead</h1>
<p>While every effort is made to do the minimal amount of work required to provide <tt class="docutils literal">errator's</tt> functionality, there is some unavoidable performance impact over non-'narrated' functions. The amount of impact is dependent on a number of factors, including the version of Python, the narration options activated, and the nature of any narration functions provided to <cite>narrate()</cite>.</p>
<p><tt class="docutils literal">errator's</tt> initial implementation was in pure Python, which introduced significant overhead to the decorated functions. Starting with the 0.3 version of <tt class="docutils literal">errator</tt>, the frequently-executed code has been moved into a C extension generated by Cython, and performance has increased significantly.</p>
<p>Starting with <tt class="docutils literal">errator</tt> 0.3, the source repository contains a timing test file, <cite>timing.py</cite>, that illustrates the differences in a variety of different usage scenarios between plain Python functions and narrated functions. Three different types of tests are executed from this file, both in a narrated variety as well as with just plain Python functions:</p>
<ul class="simple">
<li>A stack of 10 functions call each other, and an exception is raised and caught in different places in the stack. In the narration variant, when an exception is caught the narration is retrieved but discarded.</li>
<li>The same stack of 10 functions call each other, but no exceptions are ever raised.</li>
<li>A simple function is called repeatedly.</li>
</ul>
<p>Consider running this test on your target platform if there are performance concerns in the use of <tt class="docutils literal">errator</tt>, as your results may inform what functions that you want to narrate.</p>
</div>
<div class="section" id="usage-tips">
<h1>Usage tips</h1>
<ul class="simple">
<li>When decorating a method with <tt class="docutils literal">narrate()</tt> and supplying a callable, don't forget to include the <tt class="docutils literal">self</tt> argument in the callable's argument list.</li>
<li>Decorating generator functions gives unexpected results; the function will return immediately with the generator as the value, hence the narration fragment will not be retained. If you wish to get narration for generator functions, you need to use the <tt class="docutils literal">narrate_cm()</tt> context manager within the generator to accomplish this.</li>
<li>At the moment, behavior with coroutines has not been investigated, but almost certainly the current release will do surprising things. This will need further investigation.</li>
</ul>
</div>
</div>
</body>
</html>